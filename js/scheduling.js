let taskColors = [
  '#69a3f2',
  '#45e49c'
]

let deadlineStatus = {
  0: 'SUCCESS',
  1: 'FAIL',
}

/**
 * Generates a power schedule where the power state is constant
 * @param {int} duration the total duration of the schedule
 * @param {boolean} startState the power state at the start of the schedule
 * @returns an array of power states
 */
let generatePowerScheduleConstant = (duration, startState = true) => {
  return [{
    'state': startState,
    'start': 0,
    'end': duration
  }]
}

/**
 * Generates a power schedule where the power state changes periodically
 * @param {int} duration the total duration of the schedule
 * @param {int} onTime the duration of the power on period
 * @param {int} offTime the duration of the power off period
 * @param {boolean} startState the power state at the start of the schedule
 * @returns an array of power states
 */
let generatePowerSchedulePeriodic = (duration, onTime, offTime, startState = true) => {
  let result = [];
  // adjust values depending on startState
  let i = startState ? 0 : onTime;
  let end = startState ? duration : duration + onTime;
  let shift = startState ? 0 : onTime;

  for (; i < end; i++) {
    if (i % (onTime + offTime) === 0) { // on period
      // update end time of latest state
      if(result.length > 0) {
        result[result.length-1]['end'] = i-shift;
      }
      
      result.push({
        'state': true,
        'start': i-shift,
      });
    } else if ((i - onTime) % (onTime + offTime) === 0) { // off period
      // update end time of latest state
      if(result.length > 0) {
        result[result.length-1]['end'] = i-shift;
      }

      result.push({
        'state': false,
        'start': i-shift,
      });
    }
  }

  // update end time of the last state
  if(result.length > 0) {
    result[result.length-1]['end'] = duration;
  }

  return result;
}

/**
 * Generates a power schedule where the power state changes randomly
 * @param {int} duration the total duration of the schedule
 * @param {int} startState the power state at the start of the schedule
 * @returns an array of power states
 */
let generatePowerScheduleRandom = (duration, startState = true) => {
  let result = []
  let lastState = startState;
  result.push({
    'state': lastState, 
    'start': 0
  });

  for (let i = 1; i < duration; i++) {
    if (Math.random() < 0.5) {
      if(result.length > 0) {
        result[result.length-1]['end'] = i;
      }
      lastState = !lastState
      result.push({
        'state': lastState, 
        'start': i}
      );
    }
  }

  if(result.length > 0) {
    result[result.length-1]['end'] = duration;
  }

  return result;
}

/**
 * Schedules a given set of tasks over a duration with a given power schedule using EDF
 * @param {array} tasks an array of task objects to schedule
 * @param {int} duration the total duration to schedule for
 * @param {object} powerSchedule an object following the format generated by the schedule generating functions
 * @returns 
 */
let calculateScheduleEdf = (tasks, duration, powerSchedule, preemptive = true) => {
  let schedule = [];
  let runQueue = [];
  let power = powerSchedule[0];
  let powerIndex = 0;
  let chosenJob = null;
  let chosenJobIndex = 0;
  let newExecution = {
    id: 0,
    deadline: 0,
    executionTime: 0,
    start: 0,
  }

  for (let i = 0; i < duration; i++) {
    for (let j = 0; j < tasks.length; j++) {
      task = tasks[j];
      // add newly released jobs to the queue
      if (i >= task['firstRelease'] && (i - task['firstRelease']) % task['period'] === 0) {
        let newDeadline = i + parseInt(task['deadline']);
        runQueue.push({
          'id': j,
          'mandatoryTime': task['mandatoryTime'],
          'optionalTime': task['optionalTime'],
          'release': i,
          'deadline': newDeadline,
        });
      }
    }

    // update power state and continue if no power or no jobs
    if (power['end'] === i) {
      power = powerSchedule[++powerIndex];
    }
    if (!power['state'] || runQueue.length === 0) {
      continue;
    }
    
    // if preemptive or no currently running job, find a new one
    if (preemptive || chosenJob === null) {
      let tempIndex = 0;
      let tempJob = null;
      for (let j = 0; j < runQueue.length; j++) {
        if (tempJob === null || tempJob['deadline'] > runQueue[j]['deadline']) {
          tempIndex = j;
          tempJob = runQueue[j];
        }
      }

      // update if new job is found
      if (chosenJob !== tempJob) {
        if (chosenJob !== null) {
          schedule.push(newExecution);
        }

        chosenJobIndex = tempIndex;
        chosenJob = tempJob;

        newExecution = {
          id: chosenJob['id'],
          release: chosenJob['release'],
          deadline: chosenJob['deadline'],
          executionTime: 0,
          start: i,
        }
      }
    }

    if (newExecution.start === -1) newExecution.start = i;

    // decrement job time left and increment execution time
    if (chosenJob['mandatoryTime'] > 0) {
      newExecution['executionTime'] += 1;
      chosenJob['mandatoryTime'] -= 1;
    } else if (chosenJob['optionalTime'] > 0) {
      newExecution['executionTime'] += 1;
      chosenJob['optionalTime'] -= 1;
    }

    // if job has no time left push execution, remove job, and update corresponding deadline
    if (chosenJob['mandatoryTime'] <= 0 && chosenJob['optionalTime'] <= 0) {
      runQueue.splice(chosenJobIndex, chosenJobIndex+1);
      schedule.push(newExecution);
      
      // update deadline status
      newStatus = newExecution['start'] + newExecution['executionTime'] <= newExecution['deadline'] ? deadlineStatus[0] : deadlineStatus[1];
      // let foundIndex = deadlines.findIndex(d => d.time === newExecution['deadline']);
      // deadlines[foundIndex]['status'] = newStatus;
      newExecution['status'] = newStatus

      chosenJob = null;
      newExecution = {
        id: 0,
        release: 0,
        deadline: 0,
        executionTime: 0,
        start: 0,
      }
    } else if (i === duration-1 || (power['state'] && power['end'] === i+1)) { // if power loss or end of duration, push execution
      if (i === duration-1) { 
        // update deadline status
        newStatus = newExecution['start'] + newExecution['executionTime'] <= newExecution['deadline'] ? deadlineStatus[0] : deadlineStatus[1];
        // let foundIndex = deadlines.findIndex(d => d.time === newExecution['deadline']);
        // deadlines[foundIndex]['status'] = newStatus;
        newExecution['status'] = newStatus
      }
      schedule.push(newExecution);
      newExecution = {
        id: chosenJob['id'],
        release: chosenJob['release'],
        deadline: chosenJob['deadline'],
        executionTime: 0,
        start: -1,
      }
    }
  }

  return schedule;
}

let calculateScheduleOptimal = (tasks, duration, powerSchedule, preemptive = true) => {
  let schedule = [];
  let runQueuePriority = [];
  let runQueue = [];
  let power = powerSchedule[0];
  let powerIndex = 0;
  let chosenJob = null;
  let chosenIndex = 0;
  let chosenFromPriority = false;
  let newExecution = {
    id: 0,
    deadline: 0,
    executionTime: 0,
    start: 0,
  }

  for (let i = 0; i < duration; i++) {
    for (let j = 0; j < tasks.length; j++) {
      task = tasks[j];
      // add newly released jobs to the queue
      if (i >= task['firstRelease'] && (i - task['firstRelease']) % task['period'] === 0) {
        let newDeadline = i + parseInt(task['deadline']);
        let newJob = {
          'id': j,
          'mandatoryTime': task['mandatoryTime'],
          'optionalTime': task['optionalTime'],
          'release': i,
          'deadline': newDeadline,
        }

        if (newJob['mandatoryTime'] > 0) {
          runQueuePriority.push(newJob);
        } else {
          runQueue.push(newJob);
        }
      }
    }

    // update power state and continue if no power or no jobs
    if (power['end'] === i) {
      power = powerSchedule[++powerIndex];
    }
    if (!power['state'] || runQueuePriority.length === 0 && runQueue.length === 0) {
      continue;
    }

    // if preemptive or no currently running job, find a new one
    if (preemptive || chosenJob === null) {
      let tempIndex = 0;
      let tempJob = null;
      let tempFromPriority = false;
      // first search priority queue
      for (let j = 0; j < runQueuePriority.length; j++) {
        if (tempJob === null || tempJob['deadline'] > runQueuePriority[j]['deadline']) {
          tempIndex = j;
          tempJob = runQueuePriority[j];
          tempFromPriority = true;
        }
      }
      
      // if no mandatory jobs left, search runQueue
      if (tempJob === null) {
        for (let j = 0; j < runQueue.length; j++) {
          if (tempJob === null || tempJob['deadline'] > runQueue[j]['deadline']) {
            tempIndex = j;
            tempJob = runQueue[j];
          }
        }
      }

      // update if new job is found
      if (chosenJob !== tempJob) {
        if (chosenJob !== null) {
          schedule.push(newExecution);
        }

        chosenIndex = tempIndex;
        chosenJob = tempJob;
        chosenFromPriority = tempFromPriority;

        newExecution = {
          id: chosenJob['id'],
          release: chosenJob['release'],
          deadline: chosenJob['deadline'],
          executionTime: 0,
          start: i,
        }
      }
    }

    if (newExecution.start === -1) newExecution.start = i;

    // decrement job time left and increment execution time
    if (chosenJob['mandatoryTime'] > 0) {
      newExecution['executionTime'] += 1;
      chosenJob['mandatoryTime'] -= 1;
      newExecution['type'] = 'mandatory';
    } else if (chosenJob['optionalTime'] > 0) {
      newExecution['executionTime'] += 1;
      chosenJob['optionalTime'] -= 1;
      newExecution['type'] = 'optional';
    }
    
    // if job was chosen from mandatory queue, but has no mandatory time left, remove it
    if (chosenFromPriority && chosenJob['mandatoryTime'] <= 0) {
      // update deadline status
      newStatus = newExecution['start'] + newExecution['executionTime'] <= newExecution['deadline'] ? deadlineStatus[0] : deadlineStatus[1];
      // let foundIndex = deadlines.findIndex(d => d.time === newExecution['deadline']);
      // deadlines[foundIndex]['status'] = newStatus;
      newExecution['status'] = newStatus

      runQueuePriority.splice(chosenIndex, chosenIndex+1);
      schedule.push(newExecution);

      // if job still has optional time add it to optional queue
      if (chosenJob['optionalTime'] > 0) {
        runQueue.push(chosenJob);
      }

      chosenJob = null;
      newExecution = {
        id: 0,
        release: 0,
        deadline: 0,
        executionTime: 0,
        start: 0,
      }
    } else if (!chosenFromPriority && chosenJob['optionalTime'] <= 0) { // if job was optional and has no optional time left
      // update deadline status
      newStatus = newExecution['start'] + newExecution['executionTime'] <= newExecution['deadline'] ? deadlineStatus[0] : deadlineStatus[1];
      // let foundIndex = deadlines.findIndex(d => d.time === newExecution['deadline']);
      // deadlines[foundIndex]['status'] = newStatus;
      newExecution['status'] = newStatus

      runQueue.splice(chosenIndex, chosenIndex+1);
      schedule.push(newExecution);

      chosenJob = null;
      newExecution = {
        id: 0,
        release: 0,
        deadline: 0,
        executionTime: 0,
        start: 0,
      }
    } else if (i === duration-1 || (power['state'] && power['end'] === i+1)) { // if power loss or end of duration, push execution
      if (i === duration-1) {
        // update deadline status
        newStatus = newExecution['start'] + newExecution['executionTime'] <= newExecution['deadline'] ? deadlineStatus[0] : deadlineStatus[1];
        // let foundIndex = deadlines.findIndex(d => d.time === newExecution['deadline']);
        // deadlines[foundIndex]['status'] = newStatus;
        newExecution['status'] = newStatus
      }

      schedule.push(newExecution);
      newExecution = {
        id: chosenJob['id'],
        release: chosenJob['release'],
        deadline: chosenJob['deadline'],
        executionTime: 0,
        start: -1,
      }
    }
  }

  return schedule
}